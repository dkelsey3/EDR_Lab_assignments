---
title: "PredictingSPSC"
author: "Daiyanera Kelsey"
date: "2025-03-07"
output: html_document
---

```{r Importing libraries}
library(tidyverse)
library(sf)
library(terra)
library(dplyr)
library(spData)
library(tmap)
library(gstat)
library(sp)
```

```{r Set up for creating the raster}
getwd()
PWS_pool <- "Pool.shp"
PWS_elev <- "Elevation.shp"

p.PWS <- sf::read_sf(PWS_pool)
e.PWS <- sf::read_sf(PWS_elev)

glimpse(p.PWS)
glimpse(e.PWS)

p.PWS %>% sf::st_is_valid()
e.PWS %>% sf::st_is_valid()

plot(p.PWS)
plot(e.PWS)
#Need to combine shapefiles!

PWS_bind <- rbind(p.PWS, e.PWS)
plot(PWS_bind)
#Checking to see if they combined and they did :D

PWS.transform <- PWS_bind %>% sf::st_transform(., crs = "EPSG:3857")

plot(PWS.transform)
#24 geometries
PWS.transform %>% sf::st_area()
```

```{r Convert ground truth to raster}
# Polygons
print(PWS_bind)

#Define the extent of the raster based on the shapefile's bounding box
extentofPWS <- ext(st_bbox(PWS_bind))  # Use the bounding box of the shapefile

# Set raster resolution
PWScols <- 100  # Set number of columns
PWSrows <- 100  # Set number of rows

# Create an empty raster template with the specified extent and resolution
PWSrast <- rast(extentofPWS, ncols = PWScols, nrows = PWSrows)
PWSrasterized_groundtruth <- rasterize(PWS_bind, PWSrast, field = "SPSC", background = NA)
plot(PWSrasterized_groundtruth)
crs(PWSrasterized_groundtruth) <- "EPSG:3857" 
crs(PWSrasterized_groundtruth)

crs(PWS_bind)
PWSrasterized_groundtruth <- mask(crop(PWSrasterized_groundtruth, PWS_bind), PWS_bind)

#How many valid (non-NA) cells are there? 
sum(!is.na(values(PWSrasterized_groundtruth$SPSC)))
plot(!is.na(PWSrasterized_groundtruth$SPSC))

```

Now that we have the ground truth, we want to create some sampling strategies. Our goal is to see which one will produce the least amount of error and will be the closest to our created "ground truth" raster. 

```{r Randomized point distribution}
#Creating 50 random sampling points
#The cool thing about this code is that they are random every time!! 

PWS.point.random <- spatSample(PWSrasterized_groundtruth$SPSC, 50, method="random", xy=T, replace = T, as.points = T) %>%
  tidyterra::filter(., !is.na(SPSC))
  #Note about replace: If TRUE, sampling is with replacement (if method="random")
nrow(PWS.point.random)
plot(PWS.point.random)
# Convert to Spatial for gstat (required by gstat::idw)

PWSRandom_points_sp <- as(PWS.point.random, "Spatial")
#PWS.transform

# Create empty raster grid for interpolation
grid <- as.data.frame(xyFromCell(PWSrasterized_groundtruth, 1:ncell(PWSrasterized_groundtruth)))
sp::coordinates(grid) <- ~ x + y
gridded(grid) <- TRUE
proj4string(grid) <- proj4string(PWSRandom_points_sp)

# Interpolate using gstat::idw
PWS.random.idw <- idw(SPSC ~ 1, PWSRandom_points_sp, newdata = grid, idp = 2)
#Notes, breaking down the code
#formula: Defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name z, for ordinary and simple kriging use the formula z~1; for simple kriging also define beta (see below); for universal kriging, suppose z is linearly dependent on x and y, use the formula z~x+y
#newdata: object of class Spatial, sf or stars with prediction/simulation locations; should contain attributes with the independent variables (if present).
#idp: numeric; specify the inverse distance weighting power

# Convert to terra raster
PWS.random.raster <- rast(PWS.random.idw)
plot(PWS.random.raster)
```



```{r}
# First, get the raster layer with only non-NA cells
valid_cells <- which(!is.na(values(PWSrasterized_groundtruth$SPSC)))

# Create a mask that only includes those valid cells
valid_mask <- PWSrasterized_groundtruth
values(valid_mask) <- !is.na(values(PWSrasterized_groundtruth$SPSC))

# Use spatSample with that mask
PWS.point.random <- spatSample(valid_mask, 50, method="random", xy=TRUE, replace=TRUE, as.points=TRUE)

# Extract the SPSC values at those points
PWS.point.random$SPSC <- terra::extract(PWSrasterized_groundtruth$SPSC, PWS.point.random)[,2]

# Double-check
nrow(PWS.point.random)  # Should be 50 now
plot(PWS.point.random)

```

```{r Randomized point distribution within polygons based on type}

PWSrast <- rast(extentofPWS, ncols = PWScols, nrows = PWSrows)
PWSrasterized_pool <- rasterize(p.PWS, PWSrast, field = "SPSC", background = NA)
plot(PWSrasterized_pool)

PWSpoolraster_random <- spatSample(PWSrasterized_pool, 30, method="random", xy=T, replace = T, as.points = T) %>%
  tidyterra::filter(., !is.na(SPSC))
nrow(PWSpoolraster_random)
plot(PWSpoolraster_random)

PWSrasterized_elev <- rasterize(e.PWS, PWSrast, field = "SPSC", background = NA)
plot(PWSrasterized_elev)

PWSelevraster_random<- spatSample(PWSrasterized_elev, 20, method="random", xy=T, replace = T, as.points = T) %>%
  tidyterra::filter(., !is.na(SPSC))

nrow(PWSelevraster_random)
#Bind points together after sampling from different features
PWS_ep_point <- rbind(PWSelevraster_random, PWSpoolraster_random)
plot(PWS_ep_point)


#Convert sample points to sf
PWSpecom_sf <- sf::st_as_sf(PWS_ep_point)
#Then to SpatialPointsDataFrame
PWSpecom_sp <- as(PWSpecom_sf, "Spatial")


#PWS_ep_com_raster <- rasterize(PWS_ep_point, PWSrast, field = "SPSC", background = NA)
# Convert to Spatial for gstat (required by gstat::idw)
#PWSpecom_sp <- as(PWS_ep_com_raster, "Spatial")
#PWS.transform

# Create empty raster grid for interpolation
grid <- as.data.frame(xyFromCell(PWSrasterized_groundtruth, 1:ncell(PWSrasterized_groundtruth)))
sp::coordinates(grid) <- ~ x + y
gridded(grid) <- TRUE
proj4string(grid) <- proj4string(PWSpecom_sp)

# Interpolate using gstat::idw
PWS.eprandom.idw <- idw(SPSC ~ 1, PWSpecom_sp, newdata = grid, idp = 2)

# Convert to terra raster
PWS.eprandom.raster <- rast(PWS.eprandom.idw)
plot(PWS.eprandom.raster)
```

```{r Regular point distribution}
#Creating 50 grid sampling points

PWS.point.regular <- spatSample(PWSrasterized_groundtruth, 50, method="regular", xy=T, replace = T, as.points = T) %>%
  tidyterra::filter(., !is.na(SPSC))
  #Note about replace: If TRUE, sampling is with replacement (if method="random")

plot(PWS.point.regular)
# Convert to Spatial for gstat (required by gstat::idw)

PWSRegular_points_sp <- as(PWS.point.regular, "Spatial")
#PWS.transform

# Create empty raster grid for interpolation
grid <- as.data.frame(xyFromCell(PWSrasterized_groundtruth, 1:ncell(PWSrasterized_groundtruth)))
sp::coordinates(grid) <- ~ x + y
gridded(grid) <- TRUE
proj4string(grid) <- proj4string(PWSRegular_points_sp)

# Interpolate using gstat::idw
PWS.regular.idw <- idw(SPSC ~ 1, PWSRegular_points_sp, newdata = grid, idp = 2)

# Convert to terra raster
PWS.regular.raster <- rast(PWS.regular.idw)
plot(PWS.regular.raster)
```

```{r Regular point distribution within polygons based on type}

PWSrast <- rast(extentofPWS, ncols = PWScols, nrows = PWSrows)
PWSrasterized_pool <- rasterize(p.PWS, PWSrast, field = "SPSC", background = NA)
plot(PWSrasterized_pool)

PWSpoolraster_regular <- spatSample(PWSrasterized_pool, 30, method="regular", xy=T, replace = T, as.points = T) %>%
  tidyterra::filter(., !is.na(SPSC))

PWSrasterized_elev <- rasterize(e.PWS, PWSrast, field = "SPSC", background = NA)
plot(PWSrasterized_elev)

PWSelevraster_regular <- spatSample(PWSrasterized_elev, 20, method="regular", xy=T, replace = T, as.points = T) %>%
  tidyterra::filter(., !is.na(SPSC))

#Bind points together after sampling from different features
PWS_ep_pointreg <- rbind(PWSelevraster_regular, PWSpoolraster_regular)
plot(PWS_ep_pointreg)


#Convert sample points to sf
PWSpecomreg_sf <- sf::st_as_sf(PWS_ep_pointreg)
#Then to SpatialPointsDataFrame
PWSpecomreg_sp <- as(PWSpecomreg_sf, "Spatial")


#PWS_ep_com_raster <- rasterize(PWS_ep_point, PWSrast, field = "SPSC", background = NA)
# Convert to Spatial for gstat (required by gstat::idw)
#PWSpecom_sp <- as(PWS_ep_com_raster, "Spatial")
#PWS.transform

# Create empty raster grid for interpolation
grid <- as.data.frame(xyFromCell(PWSrasterized_groundtruth, 1:ncell(PWSrasterized_groundtruth)))
sp::coordinates(grid) <- ~ x + y
gridded(grid) <- TRUE
proj4string(grid) <- proj4string(PWSpecomreg_sp)

# Interpolate using gstat::idw
PWS.epreg.idw <- idw(SPSC ~ 1, PWSpecomreg_sp, newdata = grid, idp = 2)

# Convert to terra raster
PWS.epreg.raster <- rast(PWS.epreg.idw)
plot(PWS.epreg.raster)
```

```{r Randomized point distribution, increased sampling size}
#Creating 50 random sampling points
#The cool thing about this code is that they are random every time!! 

PWS.point.random.2 <- spatSample(PWSrasterized_groundtruth, 100, method="random", xy=T, replace = T, as.points = T) %>%
  tidyterra::filter(., !is.na(SPSC))
  #Note about replace: If TRUE, sampling is with replacement (if method="random")

plot(PWS.point.random.2)
# Convert to Spatial for gstat (required by gstat::idw)

PWSRandom_points2_sp <- as(PWS.point.random.2, "Spatial")
#PWS.transform

# Create empty raster grid for interpolation
grid <- as.data.frame(xyFromCell(PWSrasterized_groundtruth, 1:ncell(PWSrasterized_groundtruth)))
sp::coordinates(grid) <- ~ x + y
gridded(grid) <- TRUE
proj4string(grid) <- proj4string(PWSRandom_points2_sp)

# Interpolate using gstat::idw
PWS.random2.idw <- idw(SPSC ~ 1, PWSRandom_points2_sp, newdata = grid, idp = 2)
#Notes, breaking down the code
#formula: Defines the dependent variable as a linear model of independent variables; suppose the dependent variable has name z, for ordinary and simple kriging use the formula z~1; for simple kriging also define beta (see below); for universal kriging, suppose z is linearly dependent on x and y, use the formula z~x+y
#newdata: object of class Spatial, sf or stars with prediction/simulation locations; should contain attributes with the independent variables (if present).
#idp: numeric; specify the inverse distance weighting power

# Convert to terra raster
PWS.random2.raster <- rast(PWS.random2.idw)
plot(PWS.random2.raster)
```

```{r Regular point distribution, increased sampling size}
#Creating 50 grid sampling points

PWS.point.regular.2 <- spatSample(PWSrasterized_groundtruth, 100, method="regular", xy=T, replace = T, as.points = T) %>%
  tidyterra::filter(., !is.na(SPSC))
  #Note about replace: If TRUE, sampling is with replacement (if method="random")

plot(PWS.point.regular.2)
# Convert to Spatial for gstat (required by gstat::idw)

PWSRegular_points2_sp <- as(PWS.point.regular.2, "Spatial")
#PWS.transform

# Create empty raster grid for interpolation
grid <- as.data.frame(xyFromCell(PWSrasterized_groundtruth, 1:ncell(PWSrasterized_groundtruth)))
sp::coordinates(grid) <- ~ x + y
gridded(grid) <- TRUE
proj4string(grid) <- proj4string(PWSRegular_points2_sp)

# Interpolate using gstat::idw
PWS.regular2.idw <- idw(SPSC ~ 1, PWSRegular_points2_sp, newdata = grid, idp = 2)

# Convert to terra raster
PWS.regular2.raster <- rast(PWS.regular2.idw)
plot(PWS.regular2.raster)
```

Currently we have 6 different sampling types. 2 random - one has 50 sampling points, one has 100. 2 regular - one has 50 sampling points, one has 100. Finally, sampling 50 points based off type, pools and elevation. Our next step is to calculate the rasters. The question: Which sampling method is closest to the truth? 

```{r Calculation and getting the error margin}

Reg100 <-  PWS.regular2.raster - PWSrasterized_groundtruth
